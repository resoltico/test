# WEB2MD: CommonMark-Based Rules System Specification

## Core Architecture

WEB2MD is a Node.js CLI application that transforms HTML webpages into semantically structured Markdown documents. At the heart of this conversion process lies a strictly-defined YAML-based rules system that defines how HTML elements are transformed into their CommonMark-compliant Markdown counterparts.

The conversion engine is built on a custom CommonMark-compliant parser/renderer implemented specifically for web2md, providing fine-grained control over the transformation process while ensuring complete compliance with the CommonMark specification 0.31.2.

## System Overview

The WEB2MD architecture follows a streamlined input-process-output pipeline:

1. **Input**: HTML content from files or URLs (with customizable HTTP options)
2. **Pre-Process**: Apply deobfuscation and handle content encoding/compression
3. **Process**: Convert HTML to AST, apply transformation rules, generate Markdown
4. **Output**: Write Markdown content to file or stdout

The YAML-based rules system controls the transformation process, allowing for customization while providing sensible defaults that comply with the CommonMark spec.

## Technology Stack

The implementation relies on the following key technologies:

- Node (^22.14.0): Main engine
- commander (^13.1.0): Command-line interface parsing and execution
- chalk (^5.4.1): Terminal styling for intuitive user feedback
- node:fs/promises: Native file system operations for input/output
- got (^14.4.7): HTTP client for retrieving remote content
- jsdom (^26.1.0): DOM manipulation for HTML processing
- typescript (^5.8.3): Type safety and improved developer experience
- eslint (^9.24.0): Code quality enforcement and style consistency
- esbuild (^0.25.2): Build tool for JavaScript/TypeScript
- tsx (^4.19.3): TypeScript execution for development and testing
- zod (^3.24.2): Schema validation for configurations and rules
- js-yaml (^4.1.0): YAML parsing for rules and configuration
- tough-cookie (^5.1.2): Cookie handling for HTTP requests
- https-proxy-agent (^7.0.6): HTTP proxy support
- mathjax-node (^2.1.1): Math expression processing
- zstd-napi (^0.0.10): Zstandard compression support
- our own (that is, generated by you, Claude) Markdown core as per CommonMark Spec 0.31.2 at https://spec.commonmark.org/0.31.2/

## Diagram

flowchart TB
    subgraph "Input Layer"
        CLI[CLI Interface]
        ConfigLoader[Configuration Loader]
        FileReader[File Reader]
        URLFetcher[URL Fetcher]
    end
    
    subgraph "Pre-Processing Layer"
        ContentDecoder[Content Decoder]
        Deobfuscator[Deobfuscator]
        HTMLParser[HTML Parser]
    end
    
    subgraph "Core Conversion Pipeline"
        DOMTree[DOM Tree]
        RuleSystem[Rule System]
        ASTBuilder[Markdown AST Builder]
        ASTOptimizer[AST Optimizer]
        MarkdownRenderer[CommonMark Renderer]
    end
    
    subgraph "Specialized Processors"
        MathProcessor[Math Processor]
        TableProcessor[Table Processor]
        CodeProcessor[Code Block Processor]
    end
    
    subgraph "Rule Management"
        RuleRegistry[Rule Registry]
        RuleLoader[Rule Loader]
        direction LR
        YAMLRules[YAML Rules]
        JSRules[JS Rules]
        RuleLoader --> YAMLRules
        RuleLoader --> JSRules
    end
    
    subgraph "Output Layer"
        OutputWriter[Output Writer]
        PostProcessor[Post Processor]
    end
    
    %% Input flow
    CLI --> ConfigLoader
    CLI --> FileReader
    CLI --> URLFetcher
    
    %% Pre-processing flow
    FileReader --> ContentDecoder
    URLFetcher --> ContentDecoder
    ContentDecoder --> Deobfuscator
    Deobfuscator --> HTMLParser
    
    %% Core conversion flow
    HTMLParser --> DOMTree
    DOMTree --> ASTBuilder
    RuleSystem --> ASTBuilder
    ASTBuilder --> ASTOptimizer
    ASTOptimizer --> MarkdownRenderer
    
    %% Rule management flow
    ConfigLoader --> RuleRegistry
    RuleRegistry --> RuleLoader
    RuleLoader --> RuleSystem
    
    %% Specialized processors integration
    MathProcessor <--> ASTBuilder
    TableProcessor <--> ASTBuilder
    CodeProcessor <--> ASTBuilder
    
    %% Output flow
    MarkdownRenderer --> PostProcessor
    PostProcessor --> OutputWriter
    
    %% Information flow for configuration
    ConfigLoader --> RuleSystem
    ConfigLoader --> MathProcessor
    ConfigLoader --> ContentDecoder
    ConfigLoader --> Deobfuscator
    ConfigLoader --> OutputWriter


graph TD
    A[HTML Input] --> B[HTML Parser]
    B --> C[DOM Tree]
    
    C --> D[Node Processor]
    D --> |Apply Rules| E[AST Builder]
    
    F[Rule Registry] --> |Load Rules| D
    G[CommonMark Spec] --> |Define Grammar| E
    
    E --> H[Markdown AST]
    H --> I[AST Optimizer]
    I --> J[Markdown Renderer]
    J --> K[Markdown Output]
    
    L[HTTP Client] --> |Fetch URLs| A
    M[Deobfuscator] --> |Clean HTML| A
    N[Math Processor] --> |Handle Math| D
    
    O[Config Manager] --> F
    O --> L
    O --> M
    O --> N
    
    P[CLI Interface] --> O
    
    subgraph Core Conversion Pipeline
        B
        C
        D
        E
        H
        I
        J
    end
    
    subgraph Support Services
        L
        M
        N
    end
    
    subgraph Configuration
        F
        O
        P
    end


## HTML-to-Markdown Conversion Pipeline

The CommonMark-based conversion pipeline follows these steps:

1. **HTML Parsing**: Parse HTML into a DOM tree using jsdom
2. **DOM Traversal**: Traverse the DOM tree in a depth-first manner
3. **Node Transformation**: Apply rules to transform HTML nodes to Markdown AST nodes
4. **AST Optimization**: Optimize the Markdown AST for cleaner output
5. **Markdown Rendering**: Render the AST to CommonMark-compliant Markdown

This approach offers several advantages:
- Full compliance with the CommonMark specification
- Greater control over the conversion process
- Better support for complex HTML structures
- Improved handling of edge cases
- Enhanced customization through the rules system

## CommonMark Specification Compliance

The converter strictly follows the CommonMark specification version 0.31.2, ensuring that:

1. **Block Elements**: All block-level elements (paragraphs, lists, code blocks, etc.) are properly handled
2. **Inline Elements**: Inline formatting (emphasis, links, code, etc.) follows the CommonMark rules
3. **Precedence Rules**: Element precedence rules are correctly applied
4. **Edge Cases**: Special cases and edge conditions are handled according to the spec

The implementation passes all test cases from the CommonMark specification, ensuring reliable and consistent output.

## YAML-Based Rules System

The YAML-based rules system defines how HTML elements are transformed into Markdown. The system provides:

1. **Smart Defaults**: All built-in rules comply with the CommonMark specification
2. **Selective Activation**: Easy enabling/disabling of specific rule sets
3. **Custom Extensions**: Simple addition of custom rules
4. **Clear Precedence**: Explicit rule priority handling

### Node-Based Rule Architecture

The rules system is based on a node-based architecture where each rule:

1. **Matches**: Determines if it applies to a specific DOM node
2. **Transforms**: Converts the DOM node to a Markdown AST node
3. **Renders**: Specifies how to render the AST node to Markdown text

This three-stage process allows for complex transformations while maintaining clean separation of concerns.

### Rule Definition Formats

Rules can be defined in two formats:

#### 1. YAML Rules

Simple rules are defined in YAML for clarity and readability:

```yaml
# rules/text-formatting.yaml
rules:
  bold:
    match: "strong, b"
    transform: "strong"
    
  italic:
    match: "em, i"
    transform: "emphasis"
    
  strikethrough:
    match: "del, s, strike"
    transform: "strikethrough"
    
  highlight:
    match: "mark, span.highlight"
    transform: "highlight"
    
  code:
    match: "code"
    transform: "code"
```

The YAML rule format uses the following components:
- **match**: CSS selector(s) that match HTML elements
- **transform**: The AST node type to create
- **attributes** (optional): Array of attributes to extract from elements
- **options** (optional): Additional options for the transformation

#### 2. JavaScript Rules

Complex rules that require programmatic logic use JavaScript:

```javascript
// rules/math.js
export default {
  name: 'math',
  
  match: (node) => {
    const nodeName = node.nodeName.toLowerCase();
    
    // Match common math element types
    return nodeName === 'math' || 
           (nodeName === 'span' && node.classList.contains('math')) ||
           (nodeName === 'div' && node.classList.contains('math')) ||
           node.hasAttribute('data-math');
  },
  
  transform: (node, context) => {
    // Determine if display or inline math
    const isDisplay = 
      node.getAttribute('display') === 'block' ||
      node.classList.contains('display-math') ||
      node.nodeName.toLowerCase() === 'div';
    
    // Extract math content
    const content = node.textContent || '';
    
    // Return the appropriate AST node
    return {
      type: 'math',
      display: isDisplay,
      value: content
    };
  },
  
  render: (node, options) => {
    // Format with appropriate delimiters
    const delimiter = node.display ? options.blockMathDelimiter : options.inlineMathDelimiter;
    return `${delimiter}${node.value}${delimiter}${node.display ? '\n\n' : ''}`;
  }
};
```

JavaScript rules require:
- **name**: Unique identifier for the rule
- **match**: Function that determines if the rule applies to a node
- **transform**: Function that converts the node to an AST node
- **render**: Function that generates the Markdown output

### Rule Organization

Built-in rules are organized in a flat structure for simplicity:

```
rules/
├── blocks/
│   ├── headings.yaml         # Heading elements (h1-h6)
│   ├── paragraphs.yaml       # Paragraph handling
│   ├── lists.yaml            # Ordered and unordered lists
│   ├── blockquotes.yaml      # Blockquote handling
│   ├── code-blocks.yaml      # Code block formatting
│   └── thematic-breaks.yaml  # Horizontal rules
├── inlines/
│   ├── text-formatting.yaml  # Text formatting rules
│   ├── links.yaml            # Link formatting rules
│   ├── images.yaml           # Image handling
│   ├── code-spans.yaml       # Inline code formatting
│   └── line-breaks.yaml      # Hard and soft line breaks
├── tables.yaml               # Table conversion rules
├── math.js                   # Math expressions handling
└── deobfuscation.yaml        # Basic deobfuscation patterns
```

This organization separates block-level elements from inline elements, following the structure of the CommonMark specification.

### AST Node Types

The Markdown AST uses the following node types, based on the CommonMark specification:

#### Block Nodes
- **document**: Root node containing all other nodes
- **paragraph**: Basic paragraph of text
- **heading**: Section heading with level 1-6
- **blockquote**: Quoted block of content
- **list**: Ordered or unordered list
- **list_item**: Individual item in a list
- **code_block**: Block of code with optional language info
- **html_block**: Raw HTML block
- **thematic_break**: Horizontal rule (hr)

#### Inline Nodes
- **text**: Plain text content
- **softbreak**: Soft line break
- **hardbreak**: Hard line break
- **emphasis**: Emphasized text (usually italics)
- **strong**: Strongly emphasized text (usually bold)
- **code**: Inline code span
- **link**: Hyperlink with text, URL, and optional title
- **image**: Image with alt text, URL, and optional title
- **html_inline**: Raw HTML inline

#### Extended Nodes
- **table**: Table with headers and rows
- **math**: Mathematical expression (inline or block)
- **strikethrough**: Struck-through text
- **highlight**: Highlighted text
- **footnote**: Footnote reference
- **footnote_definition**: Footnote content definition

### Rule Resolution Process

The rule resolution process follows these steps:

1. **Retrieve Content with HTTP Options**: If retrieving from a URL, apply the configured HTTP options
2. **Decompress/Decode Content**: If the content is compressed or encoded, handle it appropriately
3. **Pre-Process Deobfuscation**: If deobfuscation is enabled, detect and decode obfuscated content
4. **Parse HTML**: Convert HTML into a DOM tree
5. **Load Rules**: Load all applicable rules from configuration
6. **Transform to AST**: Transform the DOM tree to a Markdown AST by applying rules
7. **Optimize AST**: Apply optimizations to the AST for cleaner output
8. **Render Markdown**: Convert the AST to CommonMark-compliant Markdown
9. **Apply Post-Processing**: Apply any required post-processing

The rule application algorithm follows these steps:
1. For each DOM node, find all matching rules
2. Sort rules by priority
3. Apply the highest-priority rule's transformation
4. Process child nodes recursively
5. Assemble the Markdown AST
6. Render the AST to Markdown text

### Built-in Rule Registry

The system includes a static registry of built-in rules. This registry is a fixed, explicitly defined map of rule sets to file paths that are bundled with the application. No directory scanning or dynamic discovery is performed.

```typescript
// Static registry of built-in rules
const BUILT_IN_RULES_REGISTRY = {
  // Block elements
  'headings': 'blocks/headings.yaml',
  'paragraphs': 'blocks/paragraphs.yaml',
  'lists': 'blocks/lists.yaml',
  'blockquotes': 'blocks/blockquotes.yaml',
  'code-blocks': 'blocks/code-blocks.yaml',
  'thematic-breaks': 'blocks/thematic-breaks.yaml',
  
  // Inline elements
  'text-formatting': 'inlines/text-formatting.yaml',
  'links': 'inlines/links.yaml',
  'images': 'inlines/images.yaml',
  'code-spans': 'inlines/code-spans.yaml',
  'line-breaks': 'inlines/line-breaks.yaml',
  
  // Special elements
  'tables': 'tables.yaml',
  'math': 'math.js',
  'deobfuscation': 'deobfuscation.yaml'
};
```

This registry approach ensures:
1. Only known, validated rule files are loaded
2. No directory scanning takes place
3. Complete predictability in which rules are applied
4. No possibility of loading unintended files

## Math Processing

WEB2MD includes a specialized math processor that handles mathematical expressions:

1. **MathML Processing**: Converts MathML elements to LaTeX
2. **TEX Scripts**: Processes script elements with math/tex content
3. **Data Attributes**: Handles elements with data-math, data-latex attributes
4. **LaTeX Formatting**: Ensures proper delimiting of math expressions
5. **Customizable Delimiters**: Allows customizing math delimiters via config

Math processing happens in two phases:
1. **Preprocessing**: Before HTML to Markdown conversion, to standardize math elements
2. **Post-processing**: After conversion, to ensure proper delimiter spacing

The math processor supports:
- Inline vs. block math detection
- MathML to LaTeX conversion
- Fallback mechanisms for handling errors

## HTTP and Content Handling

The HTTP module provides comprehensive options for web requests:

```yaml
# web2md.yaml configuration example
http:
  userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
  compression:
    enabled: true
    formats:
      - gzip
      - br
      - deflate
      - zstd
  requestOptions:
    timeout: 30000
    retry: 3
    followRedirects: true
    maxRedirects: 10
    throwHttpErrors: false
  cookies:
    enabled: true
    jar: true
  headers:
    Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"
    Accept-Encoding: "gzip, deflate, br, zstd"
    Accept-Language: "en-US,en;q=0.9"
  proxy:
    enabled: false
    url: "http://proxy.example.com:8080"
    auth:
      username: ""
      password: ""
```

Key features:
- **Custom User Agents**: Configurable user agent strings
- **Compression Support**: Handles gzip, brotli, deflate, and zstd
- **Cookie Management**: Automatic cookie handling with jar support
- **Proxy Support**: HTTP/HTTPS proxy with authentication
- **Custom Headers**: Configurable request headers
- **Charset Handling**: Automatic detection and conversion of character encodings

## Deobfuscation System

The deobfuscation module handles various forms of obfuscated content:

- **Cloudflare Email Protection**: Decodes Cloudflare-protected email addresses
- **Base64 Encoding**: Detects and decodes base64-encoded content
- **ROT13 Encoding**: Detects and decodes ROT13-encoded text
- **Script Cleaning**: Removes deobfuscation scripts from the HTML

The system is extensible with additional decoders for other obfuscation methods.

## User Workflow

### Basic Usage (No Configuration)

```bash
# Convert an HTML file to Markdown
web2md -f input.html -o output.md

# Convert a web page to Markdown
web2md -u https://example.com -o example.md

# Convert a web page with a custom user agent
web2md -u https://example.com -o example.md --user-agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
```

### Configuration with HTTP Options

Create a `web2md.yaml` file in your project to customize the output style and HTTP options:

```yaml
# web2md.yaml
headingStyle: setext     # Use underlined headings (===)
listMarker: "*"          # Use asterisks for lists
codeBlockStyle: indented # Use indented code blocks

# HTTP options
http:
  userAgent: "Mozilla/5.0 (compatible; WEB2MD/1.0; +https://github.com/yourname/web2md)"
  compression:
    enabled: true
    formats:
      - gzip
      - br
      - deflate

# Use all built-in rules
useBuiltInRules: true
```

### Selective Rule Activation

Specify only the built-in rule sets you need:

```yaml
# web2md.yaml
# Only use heading, formatting, link, and deobfuscation rules
builtInRules:
  - blocks/headings
  - inlines/text-formatting
  - inlines/links
  - deobfuscation
```

### Custom Rules

Add your own custom rules:

```yaml
# web2md.yaml
# Use all built-in rules
useBuiltInRules: true

# Add custom rules
customRules:
  - ./my-rules/note-boxes.yaml
  - ./my-rules/custom-callouts.js
  - ./my-rules/custom-deobfuscation.js
```

### CLI Rule Override

For quick experimentation, use the CLI rules directory override:

```bash
web2md -f example.html -o example.md --rules-dir ./experimental-rules
```

This approach uses a `manifest.yaml` file in the specified directory that explicitly lists the rule files to load:

```yaml
# ./experimental-rules/manifest.yaml
rules:
  - ./custom-headings.yaml
  - ./special-blocks.js
  - ./better-deobfuscation.js
```

## CLI Options

```
Usage: web2md [options]

Options:
  -f, --file <path>             HTML file to convert
  -u, --url <url>               URL to convert
  -o, --output <file>           Output file (default: stdout)
  --user-agent <string>         Custom user agent string (overrides config)
  --rules-dir <directory>       Use rules from directory manifest (overrides config)
  --deobfuscate                 Force enable deobfuscation (overrides config)
  --no-deobfuscate              Disable deobfuscation (overrides config)
  --debug                       Enable debug mode with detailed logging
  --save-original               Save original HTML content to file before processing
  --no-compression              Disable support for compressed responses
  --math-inline-delimiter <s>   Set delimiter for inline math (default: $)
  --math-block-delimiter <s>    Set delimiter for block math (default: $$)
  --no-math                     Disable math processing
  -h, --help                    Display help
  -V, --version                 Display version
```

## Implementation Guidelines

1. Use Node.js v22+ modern features extensively:
   - Native ESM modules
   - Top-level await
   - Array and object manipulation methods
   - New RegExp features
   - Asynchronous iteration

2. Implement a robust AST-based conversion pipeline:
   - HTML parsing with clean error handling
   - Structured AST nodes with clear typing
   - Separation of transformation and rendering logic
   - Comprehensive test coverage with CommonMark test suite

3. Follow strict security practices:
   - No dynamic `require()` or `eval()`
   - No directory traversal
   - No unchecked path resolution
   - Explicit rule loading with validation

4. Provide comprehensive error handling:
   - Graceful degradation for parsing errors
   - Detailed logging for debugging
   - Clear user feedback
   - Recovery mechanisms for malformed input

5. Structure code with clean architecture principles:
   - Clear module boundaries
   - Dependency injection
   - Interface-based design
   - Separation of concerns

## Implementation Guidelines, other

- Smart output path determination, sanitizing of paths and filenames (spaces, special characters, invalids, etc).
- Progress indicators and error handling.
- Node is installed via fnm on macOS; the project is located at ~/Tools/web2md; we have ~/Tools/web2md/.node-version for auto node version switching. We need a function for zshrc to conveniently run web2md — this function needs to allow fnm to auto-switch Node version. The purpose of the function is just to conveniently run web2md — because zshrc aliases do not work well with arguments; and we don't need to incorporate and web2md CLI functionality into the zshrc function or duplicate or mirror it from the proper web2md CLI, in any way.
- Build script in package.json.
- Remember to include the bin/ as main point of entry.
- This is a CLI project — strictly TypeScript ESM project with strict mode/type checking enabled.
- Strategize, design, architect and build the code that extensively uses and takes advantage of the Node v22+ features and capabilities.
- Before implementing any TypeScript application that integrates with third-party libraries, create a comprehensive type definition strategy that includes proper interface design, explicit type conversion functions between your domain model and external libraries, and strict type checking configuration.
- When integrating a third-party library like Turndown into a TypeScript project, thoroughly analyze the library's actual implementation and API requirements—not just its documentation—to create precise type definitions that accurately reflect the expected parameter types and structures before writing any implementation code.
- Create explicit type declaration files (.d.ts) for any third-party libraries lacking TypeScript definitions to prevent compiler errors during the build process.
- Avoid using the prepare npm script for build processes since it runs automatically during installation and may execute before dependencies are fully available.
- When utilizing build tools like esbuild with package managers such as pnpm, account for the security feature requiring explicit build script approval with pnpm approve-builds.
- Configure TypeScript properly with appropriate typeRoots, relaxed noImplicitAny settings when necessary, and correct module resolution to handle third-party dependencies effectively.
- Design CLI entry points to dynamically determine availability of bundled/unbundled code using conditional imports rather than hardcoded paths for greater resilience.
- Implement a multi-stage build process with separate TypeScript compilation and post-processing bundling steps to leverage type-checking while still producing optimized distribution files.
- Create comprehensive build scripts that explicitly manage file copying, permissions, and bundle generation rather than relying on TypeScript's compilation alone for complete build artifacts.
- Technical Requirements for DOM Integration in Node.js TypeScript Projects: a) Include the DOM library in your TypeScript configuration with "lib": ["ES2022", "DOM"] to provide access to DOM types in a Node.js environment; b) Create centralized DOM type definitions that explicitly bridge browser DOM types to Node.js by using type declarations like export type DOMNode = globalThis.Node in a dedicated types file; c) Always use explicit imports for DOM-related types rather than relying on global type availability to ensure type consistency across modules; d) Implement type guarding with nodeType checks in JavaScript rules that manipulate DOM nodes to prevent runtime errors when accessing element-specific properties; e) Add proper type casting between library-specific node types and your application's DOM type system when bridging third-party libraries like Turndown; f) Structure your application with a centralized type system that includes vendor-specific type augmentations for any DOM manipulation libraries you're using; g) Ensure JavaScript files that manipulate DOM elements have proper runtime checks since they won't benefit from TypeScript's static type checking.
